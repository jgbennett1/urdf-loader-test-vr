{"version":3,"file":"87.js","mappings":"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","sources":["webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/coarena.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/coefficient_combine_rule.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/island_manager.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/rigid_body.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/exports.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/broad_phase.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/collider.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/collider_set.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/contact.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/feature.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/narrow_phase.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/point.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/ray.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/shape.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/geometry/toi.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/math.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/event_queue.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/pipeline/world.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/rapier.js","webpack://urdf-loader-tester/./node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js"],"sourcesContent":["export class Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don’t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map","import { RawCCDSolver } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport var CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawGenericJoint, RawJointAxis, } from \"../raw\";\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n */\nexport var JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    // #if DIM3\n    JointType[JointType[\"Spherical\"] = 3] = \"Spherical\";\n    // #endif\n})(JointType || (JointType = {}));\nexport var MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\nexport class ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    frameX1() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    frameX2() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n    // #endif\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n}\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nexport class FixedImpulseJoint extends ImpulseJoint {\n}\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalImpulseJoint extends ImpulseJoint {\n}\n// #endif\nexport class JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static spherical(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static revolute(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM3\n                result = RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map","import { RawImpulseJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { ImpulseJoint,\n// #endif\n } from \"./impulse_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n        this.map.clear();\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map","import { RawIntegrationParameters } from \"../raw\";\nexport class IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp() {\n        return this.raw.erp;\n    }\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError() {\n        return this.raw.allowedLinearError;\n    }\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance() {\n        return this.raw.predictionDistance;\n    }\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations() {\n        return this.raw.maxVelocityIterations;\n    }\n    /**\n     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxVelocityFrictionIterations() {\n        return this.raw.maxVelocityFrictionIterations;\n    }\n    /**\n     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxStabilizationIterations() {\n        return this.raw.maxStabilizationIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set erp(value) {\n        this.raw.erp = value;\n    }\n    set allowedLinearError(value) {\n        this.raw.allowedLinearError = value;\n    }\n    set predictionDistance(value) {\n        this.raw.predictionDistance = value;\n    }\n    set maxVelocityIterations(value) {\n        this.raw.maxVelocityIterations = value;\n    }\n    set maxVelocityFrictionIterations(value) {\n        this.raw.maxVelocityFrictionIterations = value;\n    }\n    set maxStabilizationIterations(value) {\n        this.raw.maxStabilizationIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map","import { RawIslandManager } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    constructor(raw) {\n        this.raw = raw || new RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map","import { RawJointAxis } from \"../raw\";\nimport { JointType, } from \"./impulse_joint\";\nexport class MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case JointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case JointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n}\nexport class UnitMultibodyJoint extends MultibodyJoint {\n}\nexport class FixedMultibodyJoint extends MultibodyJoint {\n}\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n}\n// #endif\n//# sourceMappingURL=multibody_joint.js.map","import { RawMultibodyJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { MultibodyJoint,\n// #endif\n } from \"./multibody_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n        this.map.clear();\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map","import { RotationOps, VectorOps } from \"../math\";\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport var RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    restrictTranslations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbRestrictTranslations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    restrictRotations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbRestrictRotations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity fo this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(rot, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    setNextKinematicRotation(rot) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type) {\n        return this.rawSet.rbSetBodyType(this.handle, type);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\nexport class RigidBodyDesc {\n    constructor(status) {\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        this.rotation = rot;\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    setLinvel(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y, z: z };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        this.angvel = vel;\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame − The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.mass = mass;\n        this.centerOfMass = centerOfMass;\n        this.principalAngularInertia = principalAngularInertia;\n        this.angularInertiaLocalFrame = angularInertiaLocalFrame;\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     */\n    setAdditionalPrincipalAngularInertia(principalAngularInertia) {\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.restrictTranslations(false, false, false);\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    restrictRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        return this.restrictRotations(false, false, false);\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map","import { RawRigidBodySet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { VectorOps, RotationOps } from \"../math\";\nimport { RigidBody } from \"./rigid_body\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n        this.map.clear();\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createRigidBody(rawTra, rawRot, desc.gravityScale, desc.mass, rawCom, rawLv, \n        // #if DIM3\n        rawAv, rawPrincipalInertia, rawInertiaFrame, desc.translationsEnabledX, desc.translationsEnabledY, desc.translationsEnabledZ, desc.rotationsEnabledX, desc.rotationsEnabledY, desc.rotationsEnabledZ, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map","import { version as vers } from \"./raw\";\nexport function version() {\n    return vers();\n}\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\n//# sourceMappingURL=exports.js.map","import { RawBroadPhase } from \"../raw\";\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map","import { RotationOps, VectorOps } from \"../math\";\nimport { CoefficientCombineRule, } from \"../dynamics\";\nimport { Shape, Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, \n// #if DIM3\nCylinder, RoundCylinder, Cone, RoundCone, ConvexPolyhedron, RoundConvexPolyhedron,\n// #endif\n } from \"./shape\";\nimport { RayIntersection } from \"./ray\";\nimport { PointProjection } from \"./point\";\nimport { ShapeColliderTOI, ShapeTOI } from \"./toi\";\nimport { ShapeContact } from \"./contact\";\n/// Flags affecting whether or not collision-detection happens between two colliders\n/// depending on the type of rigid-bodies they are attached to.\nexport var ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a dynamic body.\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a kinematic body.\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /// Enable collision-detection between a collider attached to a dynamic body\n    /// and another collider attached to a fixed body (or not attached to any body).\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /// Enable collision-detection between a collider attached to a kinematic body\n    /// and another collider attached to a kinematic body.\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /// Enable collision-detection between a collider attached to a kinematic body\n    /// and another collider attached to a fixed body (or not attached to any body).\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /// Enable collision-detection between a collider attached to a fixed body (or\n    /// not attached to any body) and another collider attached to a fixed body (or\n    /// not attached to any body).\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /// The default active collision types, enabling collisions between a dynamic body\n    /// and another body of any type, but not enabling collisions between two non-dynamic bodies.\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /// Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotation(rot) {\n        this.colliderSet.raw.coSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotationWrtParent(rot) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNRows() {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNCols() {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n    // #endif\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, maxToi));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, maxToi) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n        let result = ShapeColliderTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, maxToi));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nexport class ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.shape = shape;\n        this.useMassProps = false;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = 0;\n        this.activeHooks = 0;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices) {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    static cuboid(hx, hy, hz) {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows − The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(nrows, ncols, heights, scale) {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    static cylinder(halfHeight, radius) {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    static cone(halfHeight, radius) {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexMesh(vertices, indices) {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const shape = new RoundConvexPolyhedron(vertices, indices, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        this.rotation = rot;\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param is - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(is) {\n        this.isSensor = is;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.useMassProps = false;\n        this.density = density;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame − The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.useMassProps = true;\n        this.mass = mass;\n        this.centerOfMass = centerOfMass;\n        this.principalAngularInertia = principalAngularInertia;\n        this.angularInertiaLocalFrame = angularInertiaLocalFrame;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map","import { RawColliderSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { RotationOps, VectorOps } from \"../math\";\nimport { Collider } from \"./collider\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n        this.map.clear();\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createCollider(rawShape, rawTra, rawRot, desc.useMassProps, desc.mass, rawCom, \n        // #if DIM3\n        rawPrincipalInertia, rawInertiaFrame, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map","import { VectorOps } from \"../math\";\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), VectorOps.fromRaw(raw.point1()), VectorOps.fromRaw(raw.point2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map","// #if DIM3\nexport var FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Edge\"] = 1] = \"Edge\";\n    FeatureType[FeatureType[\"Face\"] = 2] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 3] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map","import { RawNarrowPhase } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactsWith(collider1, f) {\n        this.raw.contacts_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionsWith(collider1, f) {\n        this.raw.intersections_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nexport class TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    normal() {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM3\n    contactTangentImpulseX(i) {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n    contactTangentImpulseY(i) {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    constructor(toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    constructor(collider, toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    constructor(collider, toi) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderToi(colliderSet.get(raw.colliderHandle()), raw.toi());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawShape } from \"../raw\";\nimport { ShapeContact } from \"./contact\";\nimport { PointProjection } from \"./point\";\nimport { RayIntersection } from \"./ray\";\nimport { ShapeTOI } from \"./toi\";\nexport class Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        switch (rawType) {\n            case ShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case ShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n            case ShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundCuboid(extents.x, extents.y, extents.z, borderRadius);\n            // #endif\n            case ShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case ShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Segment(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]));\n            // #endif\n            case ShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case ShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Triangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]));\n            // #endif\n            case ShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundTriangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]), borderRadius);\n            // #endif\n            case ShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n            case ShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n            // #if DIM3\n            case ShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case ShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case ShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case ShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case ShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case ShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the inpact can happen.\n     * @returns If the two moving shapes collider at some point along their trajectories, this retruns the\n     *  time at which the two shape collider as well as the contact information durning the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, maxToi));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolyhedron\"] = 9] = \"ConvexPolyhedron\";\n    ShapeType[ShapeType[\"Cylinder\"] = 10] = \"Cylinder\";\n    ShapeType[ShapeType[\"Cone\"] = 11] = \"Cone\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 12] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 13] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundCylinder\"] = 14] = \"RoundCylinder\";\n    ShapeType[ShapeType[\"RoundCone\"] = 15] = \"RoundCone\";\n    ShapeType[ShapeType[\"RoundConvexPolyhedron\"] = 16] = \"RoundConvexPolyhedron\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.ball(this.radius);\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx, hy, hz) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, hz, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.ConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        }\n        else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(vertices, indices, borderRadius) {\n        super();\n        this.type = ShapeType.RoundConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(this.vertices, this.indices, this.borderRadius);\n        }\n        else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows − The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(nrows, ncols, heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.nrows, this.ncols, this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cylinder;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCylinder;\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.roundCylinder(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        return RawShape.roundCone(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map","import { VectorOps } from \"../math\";\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    constructor(toi, witness1, witness2, normal1, normal2) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeTOI(raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    constructor(collider, toi, witness1, witness2, normal1, normal2) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeColliderTOI(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map","import { RawVector, RawRotation } from \"./raw\";\n/**\n * A 3D vector.\n */\nexport class Vector3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\nexport class VectorOps {\n    static new(x, y, z) {\n        return new Vector3(x, y, z);\n    }\n    static intoRaw(v) {\n        return new RawVector(v.x, v.y, v.z);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n}\n/**\n * A quaternion.\n */\nexport class Quaternion {\n    constructor(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\nexport class RotationOps {\n    static identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n    static intoRaw(rot) {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map","import { RawDebugRenderPipeline } from \"../raw\";\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map","import { RawEventQueue } from \"../raw\";\n/// Flags indicating what events are enabled for colliders.\nexport var ActiveEvents;\n(function (ActiveEvents) {\n    /// Enable collision events.\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map","export var ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nexport var SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map","import { RawPhysicsPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nexport class PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map","import { RawQueryPipeline } from \"../raw\";\nimport { PointColliderProjection, RayColliderIntersection, RayColliderToi, ShapeColliderTOI, } from \"../geometry\";\nimport { RotationOps, VectorOps } from \"../math\";\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(islands, bodies, colliders) {\n        this.raw.update(islands.raw, bodies.raw, colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(colliders, ray, maxToi, solid, groups, filter) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(colliders, this.raw.castRay(colliders.raw, rawOrig, rawDir, maxToi, solid, groups, filter));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(colliders, ray, maxToi, solid, groups, filter) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(colliders.raw, rawOrig, rawDir, maxToi, solid, groups, filter));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(colliders, ray, maxToi, solid, groups, callback, filter) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(colliders.raw, rawOrig, rawDir, maxToi, solid, groups, rawCallback, filter);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(colliders, shapePos, shapeRot, shape, groups, filter) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(colliders.raw, rawPos, rawRot, rawShape, groups, filter);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(colliders, point, solid, groups, filter) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(colliders.raw, rawPoint, solid, groups, filter));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(colliders, point, groups) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(colliders.raw, rawPoint, groups));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(colliders, point, groups, callback, filter) {\n        let rawPoint = VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(colliders.raw, rawPoint, groups, callback, filter);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(colliders, shapePos, shapeRot, shapeVel, shape, maxToi, groups, filter) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, groups, filter));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(colliders, shapePos, shapeRot, shape, groups, callback, filter) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(colliders.raw, rawPos, rawRot, rawShape, groups, callback, filter);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map","import { RawSerializationPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nimport { World } from \"./world\";\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        this.raw.free();\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map","import { BroadPhase, ColliderSet, NarrowPhase, } from \"../geometry\";\nimport { CCDSolver, IntegrationParameters, IslandManager, ImpulseJointSet, MultibodyJointSet, RigidBodySet, } from \"../dynamics\";\nimport { VectorOps } from \"../math\";\nimport { PhysicsPipeline } from \"./physics_pipeline\";\nimport { QueryPipeline } from \"./query_pipeline\";\nimport { SerializationPipeline } from \"./serialization_pipeline\";\nimport { DebugRenderBuffers, DebugRenderPipeline } from \"./debug_render_pipeline\";\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new DebugRenderPipeline(rawDebugRenderPipeline);\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.islands, this.bodies, this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations() {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based friction constraint solver can make.\n     */\n    get maxVelocityFrictionIterations() {\n        return this.integrationParameters.maxVelocityFrictionIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations for friction (default: 8).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityFrictionIterations(niter) {\n        this.integrationParameters.maxVelocityFrictionIterations = niter;\n    }\n    /**\n     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove\n     * the energy introduced by constraint stabilization.\n     */\n    get maxStabilizationIterations() {\n        return this.integrationParameters.maxStabilizationIterations;\n    }\n    /**\n     * Sets the maximum number of velocity iterations for stabilization (default: 1).\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxStabilizationIterations(niter) {\n        this.integrationParameters.maxStabilizationIterations = niter;\n    }\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, groups, filter) {\n        return this.queryPipeline.castRay(this.colliders, ray, maxToi, solid, groups, castClosure(this.colliders, filter));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, groups, filter) {\n        return this.queryPipeline.castRayAndGetNormal(this.colliders, ray, maxToi, solid, groups, castClosure(this.colliders, filter));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, groups, callback, filter) {\n        this.queryPipeline.intersectionsWithRay(this.colliders, ray, maxToi, solid, groups, callback, castClosure(this.colliders, filter));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, groups, filter) {\n        let handle = this.queryPipeline.intersectionWithShape(this.colliders, shapePos, shapeRot, shape, groups, castClosure(this.colliders, filter));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, groups, filter) {\n        return this.queryPipeline.projectPoint(this.colliders, point, solid, groups, castClosure(this.colliders, filter));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, groups) {\n        return this.queryPipeline.projectPointAndGetFeature(this.colliders, point, groups);\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, groups, callback, filter) {\n        this.queryPipeline.intersectionsWithPoint(this.colliders, point, groups, castClosure(this.colliders, callback), castClosure(this.colliders, filter));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, maxToi, groups, filter) {\n        return this.queryPipeline.castShape(this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, groups, castClosure(this.colliders, filter));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, groups, callback, filter) {\n        this.queryPipeline.intersectionsWithShape(this.colliders, shapePos, shapeRot, shape, groups, castClosure(this.colliders, callback), castClosure(this.colliders, filter));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, castClosure(this.colliders, callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactsWith(collider1, f) {\n        this.narrowPhase.contactsWith(collider1.handle, castClosure(this.colliders, f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionsWith(collider1, f) {\n        this.narrowPhase.intersectionsWith(collider1.handle, castClosure(this.colliders, f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\nfunction castClosure(set, f) {\n    return (handle) => {\n        if (!!f) {\n            return f(set.get(handle));\n        }\n        else {\n            return undefined;\n        }\n    };\n}\n//# sourceMappingURL=world.js.map","import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n//# sourceMappingURL=rapier.js.map","import * as wasm from './rapier_wasm3d_bg.wasm';\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nlet cachegetFloat32Memory0 = null;\nfunction getFloat32Memory0() {\n    if (cachegetFloat32Memory0 === null || cachegetFloat32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachegetFloat32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Spherical:3,\"3\":\"Spherical\",Generic:4,\"4\":\"Generic\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The radius of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coDensity(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coDensity(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.ptr, handle, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.ptr, handle, colliderVel.ptr, shape2.ptr, shape2Pos.ptr, shape2Rot.ptr, shape2Vel.ptr, maxToi);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.ptr, handle, collider1Vel.ptr, collider2handle, collider2Vel.ptr, max_toi);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.ptr, handle, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.ptr, handle, shape.ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {boolean} useMassProps\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(shape, translation, rotation, useMassProps, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.ptr, shape.ptr, translation.ptr, rotation.ptr, useMassProps, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, hasParent, parent, bodies.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactPair.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDebugRenderPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        return RawDebugRenderPipeline.__wrap(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr, narrow_phase.ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Create a new joint descriptor that builds spehrical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.ptr, anchor2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.ptr, anchor2.ptr, axis.ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.ptr, axes1.ptr, anchor2.ptr, axes2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.ptr, anchor2.ptr, axis.ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        return RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.ptr, params.ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawintegrationparameters_predictionDistance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityFrictionIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxStabilizationIterations() {\n        const ret = wasm.rawintegrationparameters_maxStabilizationIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityFrictionIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxStabilizationIterations(value) {\n        wasm.rawintegrationparameters_set_maxStabilizationIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        return RawMultibodyJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.ptr, params.ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr, eventQueue.ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(islands, bodies, colliders) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.ptr, islands.ptr, bodies.ptr, colliders.ptr);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @param {Function} filter\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(colliders, rayOrig, rayDir, maxToi, solid, groups, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups, addBorrowedObject(filter));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @param {Function} filter\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(colliders, rayOrig, rayDir, maxToi, solid, groups, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups, addBorrowedObject(filter));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} groups\n    * @param {Function} callback\n    * @param {Function} filter\n    */\n    intersectionsWithRay(colliders, rayOrig, rayDir, maxToi, solid, groups, callback, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, groups, addBorrowedObject(callback), addBorrowedObject(filter));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} groups\n    * @param {Function} filter\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(colliders, shapePos, shapeRot, shape, groups, filter) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, groups, addBorrowedObject(filter));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} groups\n    * @param {Function} filter\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(colliders, point, solid, groups, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.ptr, colliders.ptr, point.ptr, solid, groups, addBorrowedObject(filter));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} groups\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(colliders, point, groups) {\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.ptr, colliders.ptr, point.ptr, groups);\n        return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} groups\n    * @param {Function} callback\n    * @param {Function} filter\n    */\n    intersectionsWithPoint(colliders, point, groups, callback, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.ptr, colliders.ptr, point.ptr, groups, addBorrowedObject(callback), addBorrowedObject(filter));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {number} groups\n    * @param {Function} filter\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(colliders, shapePos, shapeRot, shapeVel, shape, maxToi, groups, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shapeVel.ptr, shape.ptr, maxToi, groups, addBorrowedObject(filter));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} groups\n    * @param {Function} callback\n    * @param {Function} filter\n    */\n    intersectionsWithShape(colliders, shapePos, shapeRot, shape, groups, callback, filter) {\n        try {\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, groups, addBorrowedObject(callback), addBorrowedObject(filter));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, aabbCenter.ptr, aabbHalfExtents.ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawrayintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawrayintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawrayintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.ptr, handle, linvel.ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.ptr, handle, angvel.ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbRestrictTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbRestrictTranslations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbRestrictRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbRestrictRotations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {number} status\n    */\n    rbSetBodyType(handle, status) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.ptr, handle, status);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.ptr, handle, force.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.ptr, handle, impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.ptr, handle, torque.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, handle, torque_impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.ptr, handle, force.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, handle, impulse.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(translation, rotation, gravityScale, mass, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.ptr, translation.ptr, rotation.ptr, gravityScale, mass, centerOfMass.ptr, linvel.ptr, angvel.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.ptr, handle, islands.ptr, colliders.ptr, joints.ptr, articulations.ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawrigidbodyset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRotation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShape.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.ptr, p2.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.ptr, p2.ptr, p3.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.ptr, p2.ptr, p3.ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shapeVel1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, shapeVel2.ptr, maxToi);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecollidertoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawshapecontact_distance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawshapecontact_point2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecontact_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecontact_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawrayintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapetoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawintegrationparameters_erp(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_call_3ed288a247f13ea5() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_a19d3173f3e1d3c5() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_6ed7121cfb42cfed() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_c09a1641c1580c07(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_7af23f65f6c64548(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_ce1e75f0ce5f7974(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_cc9018bd6f283b6f(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_f25e869e4565d2a2(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_0acb1cf9bbaf8519(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_3f554978d8793b14(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_9a9604c6888f6468(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_371cc1c92aa8feae(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_e538258cb2a6bad0(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n"],"names":["Coarena","constructor","this","fconv","Float64Array","uconv","Uint32Array","buffer","data","Array","size","set","handle","i","index","length","push","len","delete","clear","get","forEach","f","elt","getAll","filter","CCDSolver","raw","free","undefined","CoefficientCombineRule","JointType","MotorModel","ImpulseJoint","rawSet","bodySet","static","jointType","Revolute","RevoluteImpulseJoint","Prismatic","PrismaticImpulseJoint","Fixed","FixedImpulseJoint","Spherical","SphericalImpulseJoint","finalizeDeserialization","isValid","contains","body1","jointBodyHandle1","body2","jointBodyHandle2","type","frameX1","jointFrameX1","frameX2","jointFrameX2","anchor1","jointAnchor1","anchor2","jointAnchor2","UnitImpulseJoint","limitsEnabled","jointLimitsEnabled","rawAxis","limitsMin","jointLimitsMin","limitsMax","jointLimitsMax","configureMotorModel","model","jointConfigureMotorModel","configureMotorVelocity","targetVel","factor","jointConfigureMotorVelocity","configureMotorPosition","targetPos","stiffness","damping","jointConfigureMotorPosition","configureMotor","jointConfigureMotor","JointData","frame1","frame2","res","axis","intoRaw","rawAx","result","rawA1","rawA2","rawFra1","rawFra2","limits","ImpulseJointSet","map","forEachJointHandle","bodies","joint","createJoint","desc","parent1","parent2","wakeUp","rawParams","remove","unmap","forEachJointHandleAttachedToRigidBody","forEachJointAttachedToRigidBody","IntegrationParameters","dt","erp","allowedLinearError","predictionDistance","maxVelocityIterations","maxVelocityFrictionIterations","maxStabilizationIterations","minIslandSize","maxCcdSubsteps","value","IslandManager","forEachActiveRigidBodyHandle","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","SphericalMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","wake_up","RigidBodyType","RigidBody","colliderSet","lockTranslations","locked","rbLockTranslations","lockRotations","rbLockRotations","restrictTranslations","enableX","enableY","enableZ","rbRestrictTranslations","restrictRotations","rbRestrictRotations","dominanceGroup","rbDominanceGroup","setDominanceGroup","group","rbSetDominanceGroup","enableCcd","enabled","rbEnableCcd","translation","rbTranslation","rotation","rbRotation","nextTranslation","rbNextTranslation","nextRotation","rbNextRotation","setTranslation","tra","rbSetTranslation","x","y","z","setLinvel","vel","rawVel","rbSetLinvel","gravityScale","rbGravityScale","setGravityScale","rbSetGravityScale","setRotation","rot","rbSetRotation","w","setAngvel","rbSetAngvel","setNextKinematicTranslation","t","rbSetNextKinematicTranslation","setNextKinematicRotation","rbSetNextKinematicRotation","linvel","rbLinvel","angvel","rbAngvel","mass","rbMass","sleep","rbSleep","rbWakeUp","isCcdEnabled","rbIsCcdEnabled","numColliders","rbNumColliders","collider","rbCollider","bodyType","rbBodyType","setBodyType","rbSetBodyType","isSleeping","rbIsSleeping","isMoving","rbIsMoving","isFixed","rbIsFixed","isKinematic","rbIsKinematic","isDynamic","rbIsDynamic","linearDamping","rbLinearDamping","angularDamping","rbAngularDamping","setLinearDamping","rbSetLinearDamping","setAngularDamping","rbSetAngularDamping","resetForces","rbResetForces","resetTorques","rbResetTorques","addForce","force","rawForce","rbAddForce","applyImpulse","impulse","rawImpulse","rbApplyImpulse","addTorque","torque","rawTorque","rbAddTorque","applyTorqueImpulse","torqueImpulse","rawTorqueImpulse","rbApplyTorqueImpulse","addForceAtPoint","point","rawPoint","rbAddForceAtPoint","applyImpulseAtPoint","rbApplyImpulseAtPoint","RigidBodyDesc","status","centerOfMass","translationsEnabledX","translationsEnabledY","principalAngularInertia","angularInertiaLocalFrame","translationsEnabledZ","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","canSleep","sleeping","ccdEnabled","Dynamic","KinematicPositionBased","KinematicVelocityBased","TypeError","scale","setAdditionalMass","setAdditionalMassProperties","setAdditionalPrincipalAngularInertia","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","RigidBodySet","forEachRigidBodyHandle","rb","createRigidBody","rawTra","rawRot","rawLv","rawCom","rawAv","rawPrincipalInertia","rawInertiaFrame","body","islands","colliders","impulseJoints","multibodyJoints","forEachActiveRigidBody","version","BroadPhase","ActiveCollisionTypes","Collider","parent","shape","_parent","_shape","coParent","ensureShapeIsCached","coTranslation","coRotation","isSensor","coIsSensor","setSensor","coSetSensor","setShape","rawShape","coSetShape","setRestitution","restitution","coSetRestitution","setFriction","friction","coSetFriction","frictionCombineRule","coFrictionCombineRule","setFrictionCombineRule","rule","coSetFrictionCombineRule","restitutionCombineRule","coRestitutionCombineRule","setRestitutionCombineRule","coSetRestitutionCombineRule","setCollisionGroups","groups","coSetCollisionGroups","setSolverGroups","coSetSolverGroups","activeHooks","coActiveHooks","setActiveHooks","coSetActiveHooks","activeEvents","coActiveEvents","setActiveEvents","coSetActiveEvents","activeCollisionTypes","coActiveCollisionTypes","setActiveCollisionTypes","coSetActiveCollisionTypes","coSetTranslation","setTranslationWrtParent","coSetTranslationWrtParent","coSetRotation","setRotationWrtParent","coSetRotationWrtParent","shapeType","coShapeType","halfExtents","coHalfExtents","radius","coRadius","roundRadius","coRoundRadius","halfHeight","coHalfHeight","vertices","coVertices","indices","coIndices","heightfieldHeights","coHeightfieldHeights","heightfieldScale","coHeightfieldScale","heightfieldNRows","coHeightfieldNRows","heightfieldNCols","coHeightfieldNCols","coFriction","coRestitution","density","coDensity","collisionGroups","coCollisionGroups","solverGroups","coSolverGroups","containsPoint","coContainsPoint","projectPoint","solid","coProjectPoint","intersectsRay","ray","maxToi","rawOrig","origin","rawDir","dir","coIntersectsRay","castShape","collider1Vel","shape2","shape2Pos","shape2Rot","shape2Vel","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","rawShape2","coCastShape","castCollider","collider2","collider2Vel","rawCollider2Vel","coCastCollider","intersectsShape","shapePos2","shapeRot2","rawPos2","rawRot2","coIntersectsShape","contactShape","prediction","coContactShape","contactCollider","coContactCollider","castRay","coCastRay","castRayAndGetNormal","coCastRayAndGetNormal","ColliderDesc","useMassProps","DEFAULT","a","b","c","borderRadius","hx","hy","hz","nrows","ncols","heights","points","is","setDensity","setMassProperties","ColliderSet","forEachColliderHandle","createCollider","parentHandle","hasParent","isNaN","Error","ShapeContact","dist","point1","point2","normal1","normal2","distance","FeatureType","NarrowPhase","tempManifold","TempContactManifold","contactsWith","collider1","contacts_with","intersectionsWith","intersections_with","contactPair","rawPair","contact_pair","flipped","numContactManifolds","contactManifold","intersectionPair","intersection_pair","normal","localNormal1","local_n1","localNormal2","local_n2","subshape1","subshape2","numContacts","num_contacts","localContactPoint1","contact_local_p1","localContactPoint2","contact_local_p2","contactDist","contact_dist","contactFid1","contact_fid1","contactFid2","contact_fid2","contactImpulse","contact_impulse","contactTangentImpulseX","contact_tangent_impulse_x","contactTangentImpulseY","contact_tangent_impulse_y","numSolverContacts","num_solver_contacts","solverContactPoint","solver_contact_point","solverContactDist","solver_contact_dist","solverContactFriction","solver_contact_friction","solverContactRestitution","solver_contact_restitution","solverContactTangentVelocity","solver_contact_tangent_velocity","PointProjection","isInside","PointColliderProjection","featureType","featureId","colliderHandle","Ray","pointAt","RayIntersection","toi","RayColliderIntersection","RayColliderToi","ShapeType","Shape","rawType","extents","vs","Ball","Cuboid","RoundCuboid","Capsule","Segment","Polyline","Triangle","RoundTriangle","TriMesh","HeightField","Heightfield","ConvexPolyhedron","RoundConvexPolyhedron","Cylinder","RoundCylinder","Cone","RoundCone","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawPos1","rawRot1","rawVel1","rawVel2","rawShape1","shapePos","shapeRot","rawPos","rawRayOrig","rawRayDir","super","ra","rc","rawScale","ShapeTOI","witness1","witness2","ShapeColliderTOI","Vector3","VectorOps","v","new","Quaternion","RotationOps","DebugRenderBuffers","colors","DebugRenderPipeline","render","impulse_joints","multibody_joints","narrow_phase","ActiveEvents","EventQueue","autoDrain","drainCollisionEvents","ActiveHooks","SolverFlags","PhysicsPipeline","step","gravity","integrationParameters","broadPhase","narrowPhase","ccdSolver","eventQueue","hooks","rawG","stepWithEvents","filterContactPair","filterIntersectionPair","QueryPipeline","update","intersectionsWithRay","callback","rawInter","intersectionWithShape","projectPointAndGetFeature","intersectionsWithPoint","shapeVel","intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawCenter","rawHalfExtents","SerializationPipeline","serializeAll","rawGra","deserializeAll","World","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","queryPipeline","physicsPipeline","serializationPipeline","debugRenderPipeline","takeGravity","takeIntegrationParameters","takeIslandManager","takeBroadPhase","takeNarrowPhase","takeBodies","takeColliders","takeImpulseJoints","takeMultibodyJoints","takeSnapshot","debugRender","timestep","niter","createImpulseJoint","params","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","castClosure","heap","fill","getObject","idx","heap_next","takeObject","ret","dropObject","addHeapObject","obj","isLikeNone","cachegetFloat64Memory0","getFloat64Memory0","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachegetUint8Memory0","getStringFromWasm0","ptr","Uint8Array","subarray","retptr","r0","r1","_assertClass","instance","klass","name","stack_pointer","addBorrowedObject","cachegetFloat32Memory0","getFloat32Memory0","Float32Array","getArrayF32FromWasm0","cachegetUint32Memory0","getUint32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","passArray32ToWasm0","handleError","args","apply","e","Object","freeze","Generic","AccelerationBased","ForceBased","RawJointAxis","X","Y","Z","AngX","AngY","AngZ","Vertex","Edge","Face","Unknown","Compound","RawBroadPhase","create","prototype","__destroy_into_raw","__wrap","RawCCDSolver","RawColliderSet","RawVector","RawRotation","v0","slice","r2","colliderVel","RawShape","RawShapeTOI","collider2handle","max_toi","RawShapeColliderTOI","RawShapeContact","RawPointProjection","rayOrig","rayDir","RawRayIntersection","is_sensor","events","types","angularInertiaFrame","RawRigidBodySet","RawIslandManager","isHandleValid","RawContactManifold","RawContactPair","RawDebugRenderPipeline","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","RawDeserializedWorld","RawIntegrationParameters","RawEventQueue","RawGenericJoint","axes1","axes2","handle1","handle2","RawPhysicsPipeline","joints","articulations","ccd_solver","hookObject","hookFilterContactPair","hookFilterIntersectionPair","RawPointColliderProjection","RawQueryPipeline","RawRayColliderToi","RawRayColliderIntersection","allow_x","allow_y","allow_z","at","torque_impulse","rbUserData","rbSetUserData","translationEnabledX","translationEnabledY","translationEnabledZ","rotationEnabledX","rotationEnabledY","rotationEnabledZ","rb_type","RawSerializationPipeline","ptr0","len0","ptr1","len1","p1","p2","p3","xyz","yxz","zxy","xzy","yzx","zyx","__wbindgen_object_drop_ref","arg0","__wbindgen_number_new","__wbindgen_number_get","arg1","__wbindgen_boolean_get","__wbg_rawraycolliderintersection_new","__wbindgen_is_function","__wbg_call_3ed288a247f13ea5","arg2","call","arguments","__wbg_call_a19d3173f3e1d3c5","arg3","__wbg_call_6ed7121cfb42cfed","arg4","__wbg_bind_c09a1641c1580c07","bind","__wbg_buffer_7af23f65f6c64548","__wbg_newwithbyteoffsetandlength_ce1e75f0ce5f7974","__wbg_new_cc9018bd6f283b6f","__wbg_set_f25e869e4565d2a2","__wbg_length_0acb1cf9bbaf8519","__wbg_newwithbyteoffsetandlength_3f554978d8793b14","__wbg_set_9a9604c6888f6468","__wbg_length_371cc1c92aa8feae","__wbg_newwithlength_e538258cb2a6bad0","__wbindgen_throw","__wbindgen_memory"],"sourceRoot":""}